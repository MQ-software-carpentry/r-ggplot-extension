---
title: "Visualising continuous data with ggplot2"
teaching: 120
exercises: 60
questions:
  - "What are the components of a ggplot?"
  - "How do I create histograms, density plots, and scatterplots?"
  - "How can I change the aesthetics (ex. colour, transparency) of my plot?"
objectives:
   - "Produce histograms, density plots and scatterplots using ggplot."
   - "Set universal plot settings."
keypoints:
   - "`ggplot2` is a flexible and useful tool for creating plots in R."
   - "The data set and coordinate system can be defined using the `ggplot` function."
   - "Additional layers, including geoms, are added using the `+` operator."
   - "Histograms and density plots are useful tools to visualise the distribution a a continuous variable."
   - "Scatterplots can be useful in understanding the relationship between two continuous variables."
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("01-")
source("../bin/download_data.R")
set.seed(20190213)
```

We start by loading the required package. **`ggplot2`** is also included in the
**`tidyverse`** package.

```{r load-package, message=FALSE, purl=FALSE, warning=FALSE}
library(tidyverse)
```

The data is available as part of the project you cloned from GitHub during
the previous lesson. Switch to that project now if you haven't opened it
in RStudio already.


```{r load-data, purl=FALSE}
interviews_plotting <- read_csv("data_output/interviews_plotting.csv")
```

Before we proceed to plot the data, let's take a quick look at what we
just loaded.

```{r view-data, eval=FALSE}
View(interviews_plotting)
```

## Plotting with **`ggplot2`**

**`ggplot2`** is a plotting package that makes it simple to create complex plots
from data stored in a data frame. It provides a programmatic interface for
specifying what variables to plot, how they are displayed, and general visual
properties. Therefore, we only need minimal changes if the underlying data
change or if we decide to change from a bar plot to a scatterplot. This helps in
creating publication quality plots with minimal amounts of adjustments and
tweaking.

**`ggplot2`** functions like data in the 'long' format, i.e., a column for every
dimension, and a row for every observation. Well-structured data will save you
lots of time when making figures with **`ggplot2`**

ggplot graphics are built step by step by adding new elements. Adding layers in
this fashion allows for extensive flexibility and customization of plots.

To build a ggplot, we will use the following basic template that can be used for different types of plots:

```
ggplot(data = <DATA>, mapping = aes(<MAPPINGS>)) +  <GEOM_FUNCTION>()
```

- use the `ggplot()` function and bind the plot to a specific data frame using
  the `data` argument

```{r ggplot-steps-1, eval=FALSE, purl=FALSE}
ggplot(data = interviews_plotting)
```

- define a mapping (using the aesthetic (`aes`) function), by selecting the variables to be plotted
  and specifying how to present them in the graph, e.g. as x/y positions or characteristics such as
  size, shape, color, etc.

> ## Exercise
> 
> We would like to inspect the data for a potential relationship between the number of
> people living in a household (`no_members`) and the number of items owned by that
> household (`number_items`). What would be a good way to visualise these data?
>
> > ## Solution
> >
> > Since we are dealing with two continuous variables, a scatterplot seems like
> > a good starting point. However, both of these variables only take a relatively
> > small number of discrete values. Under these circumstances a scatterplot may
> > be problematic. Let's take a look.
> {: .solution}
{: .challenge}


```{r ggplot-steps-2, eval=FALSE, purl=FALSE}
ggplot(data = interviews_plotting, aes(x = no_membrs, y = number_items))
```

- add 'geoms' â€“ graphical representations of the data in the plot (points,
lines, bars). **`ggplot2`** offers many different geoms; we will use some
common ones today, including:

* `geom_point()` for scatter plots, dot plots, etc.
* `geom_boxplot()` for, well, boxplots!
* `geom_line()` for trend lines, time series, etc.

To add a geom to the plot use the `+` operator. To create a scatterplot we
want the data to be represented as points, which can be achieved with `geom_point()`:

```{r first-ggplot, purl=FALSE}
ggplot(data = interviews_plotting, aes(x = no_membrs, y = number_items)) +
    geom_point()
```

The `+` in the **`ggplot2`** package is particularly useful because it allows
you to modify existing `ggplot` objects. This means you can easily set up plot
templates and conveniently explore different types of plots, so the above plot
can also be generated with code like this:

```{r first-ggplot-with-plus, eval=FALSE, purl=FALSE}
# Assign plot to a variable
interviews_plot <- ggplot(data = interviews_plotting, aes(x = no_membrs, y = number_items))

# Draw the plot
interviews_plot +
    geom_point()
```

> ## Notes
>
> - Anything you put in the `ggplot()` function can be seen by any geom layers
>   that you add (i.e., these are universal plot settings). This includes the x-
>   and y-axis mapping you set up in `aes()`.
> - You can also specify mappings for a given geom independently of the mapping
>   defined globally in the `ggplot()` function.
> - The `+` sign used to add new layers must be placed at the end of the line
>   containing the *previous* layer. If, instead, the `+` sign is added at the
>   beginning of the line containing the new layer, **`ggplot2`** will not add
>   the new layer and will return an error message.
{: .callout}

```{r ggplot-with-plus-position, eval=FALSE, purl=FALSE}
## This is the correct syntax for adding layers
interviews_plot +
    geom_point()

## This will not add the new layer and will return an error message
interviews_plot
+ geom_point()
```

## Building your plots iteratively

Building plots with **`ggplot2`** is typically an iterative process. We start by
defining the dataset we'll use, lay out the axes, and choose a geom:
	
```{r create-ggplot-object, purl=FALSE}
ggplot(data = interviews_plotting, aes(x = no_membrs, y = number_items)) +
    geom_point()
```

Then, we start modifying this plot to extract more information from it.

> ## Exercise
>
> Because many households share the same values for size and number of items a lot
> of points in our plot end up on top of each other. That makes it hard to see how
> common a given combination is. How could we modify the plot to avoid this problem?
>
> > ## Solution
> > 
> > There are several options, including switching to a different type of plot entirely.
> > For now, let's strick with a scatterplot. We could improve the plot by adding
> > transparency to the points. Another option is to add a small amount of jitter to each
> > point. Together these will avoid most of the overplotting and make it possible to see
> > overlapping points when it does happen.
> {: .solution}
{: .challenge}

We can add transparency using the `alpha` option:

```{r adding-transparency, purl=FALSE}
ggplot(data = interviews_plotting, aes(x = no_membrs, y = number_items)) +
    geom_point(alpha = 0.5)
```

> ## Note
>
> When setting a mapping to a constant (e.g. `alpha = 0.5` above) these
> can be set directly, without requiring a call to `aes()`.
{: .callout}

That only helped a little bit with the overplotting problem. We can also
introduce a little bit of randomness into the position of our points
using the `geom_jitter()` function.

```{r adding-jitter, purl=FALSE}
ggplot(data = interviews_plotting, aes(x = no_membrs, y = number_items)) +
    geom_jitter(alpha = 0.5)
```

That is a bit better but now the points with similar *x* and *y* values are a
bit difficult to distinguish. We can fix that by reducing the amount of horizontal
jitter using the `width` argument.


```{r reduce-jitter}
ggplot(data = interviews_plotting, aes(x = no_membrs, y = number_items)) +
    geom_jitter(alpha = 0.5, width = 0.15, height = 0.15)
```

Now the points for each combination of `no_membrs` and `number_items` form small clusters
that can be distinguished visually. 

> ## Exercise
>
> It may be possible to enhance the appearance of the plot further by changing
> the size of the points. Use the `size` argument to change the point size.
> Combine this with the `width` and `height` arguments to adjust the jitter.
>
> Try a few different values. Which one do you like best?
> > ## Solution
> >
> > Here is one possible solution.
> > 
> > ```{r increase-point-size}
> > ggplot(data = interviews_plotting, aes(x = no_membrs, y = number_items)) +
> >     geom_jitter(alpha = 0.5, width = 0.2, height = 0.2, size = 4)
> > ```
> {: .solution}
{: .challenge}


We can also add colors for all the points:

```{r adding-colors, purl=FALSE}
ggplot(data = interviews_plotting, aes(x = no_membrs, y = number_items)) +
geom_jitter(alpha = 0.5, width = 0.2, height = 0.2, size = 3, color = "blue")
```

Or to color each village in the plot differently, you could use a vector as an input to the argument **`color`**.
Because we are now mapping features of the data to a color, instead of setting one color for all points,
the color now needs to be set inside a call to the **`aes`** function. **`ggplot2`** will provide a different color
corresponding to different values in the vector. 
Here is an example where we color by **`village`**:


```{r color-by-village, purl=FALSE}
ggplot(data = interviews_plotting, aes(x = no_membrs, y = number_items)) +
    geom_jitter(aes(color = village), alpha = 0.5, width = 0.2, height = 0.2, size = 3)
```

There appears to be a positive trend between number of household
members and number of items owned (from the list provided). This trend
does not appear to be different by village.

You can highlight this aspect of the data by adding a regression line
to the plot. The function `geom_smooth` allows you to add a a variety
of different smoothing functions to the plot. You can choose the type
of smoother to use by setting the `method` argument. Use `method='lm'`
to get a regression line.

```{r regression-line, purl=FALSE}
ggplot(data = interviews_plotting, aes(x = no_membrs, y = number_items)) +
    geom_jitter(aes(color = village), alpha = 0.5, width = 0.2, height = 0.2, size = 3) +
    geom_smooth(method='lm')
```

> ## Exercise
>
> Add separate regression lines for each village.
> 
> **Hint:** Asking *ggplot* to map `village` to an aesthetic when drawing the regression
> lines will produce one line per village.
>
> > ## Solution
> >
> > ```{r village-regression-line, purl=FALSE}
> > ggplot(data = interviews_plotting, aes(x = no_membrs, y = number_items)) +
> >     geom_jitter(aes(color = village), alpha = 0.5, width = 0.2, height = 0.2, size = 3) +
> >     geom_smooth(aes(color = village), method='lm')
> > ```
> {: .solution}
{: .challenge}


> ## Exercise
>
> Use what you just learned to create a scatter plot of `rooms` by `village`
> with the `respondent_wall_type` showing in different colors. Is this a good
> way to show this type of data?
>
> > ## Solution
> >
> > ```{r scatter-challenge, answer=TRUE, purl=FALSE}
> > ggplot(data = interviews_plotting, aes(x = village, y = rooms)) +
> > geom_jitter(aes(color = respondent_wall_type))
> > ```
> {: .solution}
{: .challenge}

{% include links.md %}
